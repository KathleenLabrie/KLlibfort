	SUBROUTINE QSORT(A,N,M)
C
C THIS SUBROUTINE IS AN IMPLEMENTATION OF HOARE'S QUICKSORT
C USING THE ALGORITHIM GIVEN BY KNUTH IN "THE ART OF COMPUTER
C PROGRAMING", VOL. 3, PAGES 116-123.
C TO PROTECT AGAINST N**2 BEHAVIOR FOR WELL ORDERED DATA, THE
C PARTITIONING IS DONE USING THE MEDIAN OF THE LEFT, RIGHT, AND
C MIDDLE VALUE.  THIS ALSO SPEEDS UP THE SORT SLIGHTLY.
C
C A IS THE DATA ARRAY.  VALUES TO BE SORTED ARE IN POSITIONS
C 1 THROUGH N. THE DATA ARRAY A SHOULD BE OF AT LEAST LENGTH
C N+2.
C
C SUBFILES OF LENGTH LE M ARE SORTED WITH A STRAIGHT INSERTION SORT.
C
C CAUTIONS:  THE STACK SIZE IS SUFFICIENT FOR DATA ARRAYS SHORTER
C THAN 10**6 ELEMENTS.  VALUES CLOSE TO THE MAXIMUM ALLOWABLE
C SINGLE PRECISION FLOATING POINT VALUE WILL SCREW THINGS UP IF
C THEY ARE LARGER THAN THE TWO ARTIFICIAL BOUNDARY KEYS.
C
C
	INTEGER N,M,ISTACK(2,20),ISP,IL,IR,I,J
C
C NOTE: FOR SORTING OTHER DATA TYPES THAN REAL, CHANGE THE SPECIFICATION
C OF THE FOLLOWING STATEMENT, AND CHANGE THE VALUE FOR BOUND_KEY TO A
C VALUE NEAR OR AT THE MAXIMUM PERMITTED FOR THE STATED DATA TYPE.
C
	REAL A(1), AK, BOUND_KEY /1.6E38/
C
C-- MOVE ARRAY UP ONE ELEMENT
 	DO 387 I=N+1,2,-1
387	A(I)=A(I-1)
C
C-- INITIALIZE BOUNDARY KEYS, STACK, AND POINTERS
	A(1)=-BOUND_KEY
	A(N+2)=BOUND_KEY
	ISP=0
	IL=2
	IR=N+1
C
C-- PARTITION THE CURRENT SUBFILE IF ITS LENGTH IS GT M.  DO THIS
C   BY POSITIONING ALL KEYS SMALLER THAN AK TO ITS LEFT AND ALL
C   LARGER KEYS TO ITS RIGHT.
10	CONTINUE
	DO WHILE ((IR-IL).GE.M)
C-- FIND THE MEDIAN VALUE OF THE LEFT, RIGHT, AND MIDDLE
C   ELEMENTS.  USE IT AS THE PARTITIONING KEY.
	  I=0.5*(IL+IR)
	  AK=A(I)
	  IF (A(IL).LE.AK) THEN
	    IF (A(IR).LE.A(IL)) THEN
	      AK=A(IL)
	    ELSE IF (A(IR).LE.AK) THEN
	      AK=A(IR)
	      A(IR)=A(IL)
	    ELSE
	      A(I)=A(IL)
	    END IF
	  ELSE IF (A(IL).LE.A(IR)) THEN
	    AK=A(IL)
	  ELSE IF (A(IR).LE.AK) THEN
	    A(I)=A(IL)
	  ELSE
	    AK=A(IR)
	    A(IR)=A(IL)
	  END IF
C
	  I=IL
	  J=IR
C-- WORK IN FROM RIGHT
20	  CONTINUE
	  DO WHILE (AK.LT.A(J))
	    J=J-1
	  END DO
	  IF (J.LE.I) THEN !PARTITION COMPLETED
	    A(I)=AK
	    GOTO 30
	  END IF
	  A(I)=A(J)
	  I=I+1
C-- WORK IN FROM LEFT
	  DO WHILE (A(I).LT.AK)
	    I=I+1
	  END DO
	  IF (J.LE.I) THEN !PARTITION COMPLETED
	    A(J)=AK
	    I=J
	    GOTO 30
	  END IF
	  A(J)=A(I)        !ELSE WORK IN FROM RIGHT AGAIN
	  J=J-1
	  GOTO 20
C
C--PARTITION COMPLETED.  PUT THE LONGER OF THE TWO SUBFILES
C--ON THE STACK
30	  CONTINUE
	  ISP=ISP+1
	  IF ((IR-I).GE.(I-IL)) THEN
	    ISTACK(1,ISP)=I+1
	    ISTACK(2,ISP)=IR
	    IR=I-1
	  ELSE
	    ISTACK(1,ISP)=IL
	    ISTACK(2,ISP)=I-1
	    IL=I+1
	  END IF
	END DO
C
C-- THERE IS A SUBFILE WITH A LENGTH LESS THAN M.  SORT IT WITH
C   A STRAIGHT INSERTION SORT.
	DO J=IL+1,IR
	  AK=A(J)
	  I=J-1
	  DO WHILE (AK.LT.A(I))
	    A(I+1)=A(I)
	    I=I-1
	  END DO
	  A(I+1)=AK
	END DO
C
C-- IF THE STACK IS NOT EMPTY, TAKE THE NEXT SUBFILE AND EITHER
C   PARTITION OR SORT IT
	IF (ISP.NE.0) THEN
	  IL=ISTACK(1,ISP)
	  IR=ISTACK(2,ISP)
	  ISP=ISP-1
	  GOTO 10
	END IF
C
C-- MOVE ARRAY BACK DOWN ONE ELEMENT
	DO 388 I=1,N
388	A(I)=A(I+1)
C
	RETURN
	END
